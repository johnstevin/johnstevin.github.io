---
layout: post
title: 简单工厂、工厂方法模式、抽象工厂模式简介及区别
categories: SoftwareDesign
description: 简单工厂、工厂方法模式、抽象工厂模式简介及区别
keywords: 软件设计,软件架构
---

#### 简单工厂模式

简单工厂模式是创建型模式的一种（创建型、结构型、行为型），通过专门定义一个类来负责创建具体类型的实例，要创建的实例一般继承自同一个类；

结构一般如下所示：

![图一](http://o9w2lbvnn.bkt.clouddn.com/images/SD/gongchangmoshi/gongchangmoshi1.png)

按照面向过程的习惯，可能直接在客户端中根据条件来创建不同的具体产品实例；对于简单工厂模式而言，是把这部分逻辑抽象出来，放在一个工厂类中，由工厂类负责产生具体的对象，也就是将生产者和消费者分离了。

如上所示，工厂模式中的角色一般包括：

1、工厂角色：

即上图中的JuiceFactory，它可以被客户端调用，其内部负责创建具体的对象；

2、抽象产品类：

即上图中的抽象类Juice，它描述了所有实例公共的接口；

3、具体产品类

即上图中的appleJuice等，实现抽象产品的接口，是工厂角色中要创建的具体实例；

对于简单工厂模式，如果要新增产品，除了新增具体产品类之外，还要修改工厂类；

**简单工厂优缺点总结**

优点：从上面的描述可以看出，工厂角色负责产生具体的实例对象，所以在工厂类中需要有必要的逻辑，通过客户的输入能够得到具体创建的实例；所以客户端就不需要感知具体对象是怎么产生的，只需要将必要的信息提供给工厂即可；

缺点：简单工厂模式是违反“开闭原则”，即对扩展开放，对修改关闭；因为如果要新增具体产品，就需要修改工厂类的代码；

#### 工厂方法模式

工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法让类把实例化推迟到了子类。

工厂方法模式是针对每种商品提供一个工厂类，在客户端中判断使用哪个工厂类来创建对象；

![图一](http://o9w2lbvnn.bkt.clouddn.com/images/SD/gongchangmoshi/gongchangmoshi2.png)

对于简单工厂而言，创建对象的逻辑判断放在了工厂类中，客户不感知具体的类，但是工厂类违反了开闭原则，如果要新增新的具体类，就必须修改工厂类；

对于工厂模式而言，是通过扩展来新增具体类的，但是在客户端就必须感知到具体的类了，要通过具体类的创建工厂来创建具体的实例，也就是判断逻辑由简单工厂的工厂类挪到了客户端中；

工厂模式横向扩展很方便；

#### 抽象工厂模式

抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类；

![图一](http://o9w2lbvnn.bkt.clouddn.com/images/SD/gongchangmoshi/gongchangmoshi3.png)

ProductA 和ProductB对应的是两类产品，ConcreateFactory1和ConcreateFactory2对应的类似两个产品线，他们都分别生产ProductA和ProductB；

例如：车门和轮胎对应两个产品，宝马和奥迪对应两个产品线;

#### 三种工厂模式对比
     
简单工厂模式包括一个抽象产品类和一个具体工厂类，产生对象的逻辑判断放在工厂类中，扩展产品时，需要修改工厂类，因此工厂类违反了开闭原则；

工厂方法模式包括一个抽象产品类和一个抽象工厂类，每个产品对应一个具体的工厂类，且每个具体的工厂类只能生产一个具体产品类的实例；

抽象工厂模式包括多个抽象产品类和一个抽象工厂类，且每个具体工厂类可能生产多个具体产品类的实例；

原文出自：[这里](http://blog.csdn.net/bill_yang88/article/details/41787923)